declare class Node<T> {
    val: T;
    prev?: Node<T>;
    next?: Node<T>;
    constructor(val: T, prev?: Node<T>, next?: Node<T>);
}
/**
 * A doubly-linked list.
 *
 * ```ts
 * const list = new DLinkedList<number>()
 * list.push(2)
 * list.unshift(1)
 * list.append([3, 4])
 * list
 *   .filter((num) => n % 2 === 0)
 *   .map((num) => n * 2)
 *   .forEach((num) => console.log(num))
 * ```
 */
export declare class DLinkedList<T> implements Iterable<T> {
    first?: Node<T>;
    last?: Node<T>;
    private _length;
    /**
     * Number of elements in the list.
     */
    get length(): number;
    /**
     * Pop an element from the start of the list.
     */
    shift(): T | undefined;
    /**
     * Pop an element from the end of the list.
     */
    pop(): T | undefined;
    /**
     * Push an element to the start of the list.
     *
     * @param val Element to push.
     */
    unshift(val: T): void;
    /**
     * Push an element to the end of the list.
     *
     * @param val Element to push.
     */
    push(val: T): void;
    /**
     * Push a sequence of elements to the start of the list.
     *
     * @param vals Elements to push.
     */
    prepend(vals: Iterable<T>): void;
    /**
     * Push a sequence of elements to the end of the list.
     *
     * @param vals Elements to push.
     */
    append(vals: Iterable<T>): void;
    /**
     * Empty the list.
     */
    clear(): void;
    /**
     * Make instance iterable.
     */
    [Symbol.iterator](): Iterator<T>;
    /**
     * Iterate through the list.
     */
    forEach(fn: (x: T) => void): void;
    /**
     * Map the list elements.
     *
     * @returns A new list instance.
     */
    map<U>(fn: (x: T) => U): DLinkedList<U>;
    /**
     * Filter the list.
     *
     * @returns A new list instance.
     */
    filter(predicate: (x: T) => boolean): DLinkedList<T>;
    /**
     * Perform reduce on the list.
     *
     * @returns The reduced value.
     */
    reduce<U>(fn: (prev: U, curr: T) => U, initialValue?: U): U;
    /**
     * Find a specific element in the list.
     *
     * @returns Element found or `undefined` otherwise.
     */
    find(predicate: (x: T) => boolean): T | undefined;
    /**
     * Check if at least one element meets the predicate.
     */
    some(predicate: (x: T) => boolean): boolean;
    /**
     * Check if all elements meet the predicate.
     */
    every(predicate: (x: T) => boolean): boolean;
    toString(): string;
}
export {};
