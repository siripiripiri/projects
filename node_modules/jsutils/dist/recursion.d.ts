declare type Locals = {
    [key: string]: any;
};
/**
 * You can use this context for storing local variables and/or specify
 * recursions you need to perform and their parameters.
 */
export declare type StartContext<Param> = {
    /**
     * You can set local variables for the current call with this.
     */
    locals?: Locals;
    /**
     * Specify all the recursions and their parameters with this.
     */
    recursions?: Param[];
};
/**
 * It implements an iterative execution of the given recursion. That is,
 * you write an algorithm in a recursive way, but you get an iterative
 * execution of it.
 *
 * The running is divided into 2 phases. In `start` phase, you write
 * everything that runs before recursions, you also specify recursions
 * you want to run here; In `consume` phase, you consume all the recursive
 * calls' returns.
 *
 * **NOTE:** Because it has only 2 phases, it can't support all kinds
 * of recursion usage, for more complex usages you can use {@link recurse}.
 * For simpler ones however, this function is faster.
 *
 * @example
 * ```ts
 * function factorial(n: number) {
 *   return rec2iter(
 *     (n, context) => {
 *       if (n <= 1) return 1
 *       context.recursions = [n - 1]
 *     },
 *     (n, [fac_n_minus_1]) => n * fac_n_minus_1,
 *     n,
 *   )
 * }
 * ```
 *
 * @param start The start phase where you write everything that runs before
 * recursive calls. You also specify what recursions you want to run next
 * here.
 * @param consume The consume phase where you can get all recursive calls'
 * return values.
 * @param param The initial parameters to kick off the recursion.
 *
 * @returns The result of the whole recursion.
 */
export declare function rec2iter<Param, Return>(start: (param: Param, context: StartContext<Param>) => Return | void, consume: (param: Param, returns?: Return[], locals?: Locals) => Return, param: Param): Return;
/**
 * It implements an iterative execution of the given recursion. That is,
 * you write an algorithm in a recursive way, but you get an iterative
 * execution of it.
 *
 * @example
 * ```ts
 * function factorial(n: number) {
 *   return recurse<number, number>(function* (n) {
 *     if (n <= 1) return 1
 *     return n * (yield n - 1)
 *   }, n)
 * }
 * ```
 *
 * @param body A generator function working as the main body for recursion,
 * it yields recursions.
 * @param initialParam Initial parameter.
 */
export declare function recurse<Param, Return>(body: (param: Param) => Generator<Param, Return, Return>, initialParam: Param): Return;
export {};
