/**
 * The accessor function that returns the child nodes if any.
 */
export declare type ChildrenGetter<T> = (node: T) => T[] | undefined | null;
/**
 * Context of the current non-leaf node.
 */
export declare class TraversalContext<Param, Return> {
    /**
     * Parameters given to the current processing.
     */
    param: Param;
    /**
     * Local data specific to this context.
     */
    locals: {
        [key: string]: any;
    };
    /**
     * The value of each child after evaluation.
     */
    childReturns: Return[];
    /**
     * The value the current processing returns.
     */
    returnValue?: Return;
    constructor(param: Param);
}
/**
 * Node processing.
 *
 * If this is a non-leaf node handler and you want to return prematurely,
 * you can push the return value in `context.childReturns` and gives a
 * `true` as function's return value.
 *
 * If this is a leaf node handler, you can push the return value into
 * `context.childReturns`.
 *
 * @returns True if you want to interrupt the traversal of the rest of
 * the nodes.
 */
export declare type NodeHandler<T, Param, Return> = (node: T, context: TraversalContext<Param, Return>, index: number) => boolean | void;
export declare type DfsOptions<T, Param, Return> = {
    /**
     * Handling of non-leaf node at pre-order position.
     */
    onPre?: NodeHandler<T, Param, Return>;
    /**
     * Handling of non-leaf node at post-order position.
     */
    onPost?: NodeHandler<T, Param, Return>;
    /**
     * Handling of non-leaf node at in-order position.
     */
    onIn?: NodeHandler<T, Param, Return>;
    /**
     * Handling of leaf node.
     */
    onLeaf?: NodeHandler<T, Param, Return>;
};
/**
 * This is a general and efficient iterative version of depth first
 * search/traversal.
 *
 * @example
 * ```ts
 * type ExprNode = {
 *   op?: "+" | "-" | "*"
 *   val?: number
 *   children?: ExprNode[]
 * }
 *
 * const expr: ExprNode = {
 *   op: "+",
 *   children: [
 *     {
 *       op: "*",
 *       children: [{ val: 3 }, { val: 4 }, { val: 1 }],
 *     },
 *     {
 *       op: "-",
 *       children: [{ val: 7 }, { val: 3 }],
 *     },
 *   ],
 * }
 *
 * const ops = {
 *   "+": (nums: number[]) => nums.reduce((result, x) => result + x),
 *   "-": (nums: number[]) => nums.reduce((result, x) => result - x),
 *   "*": (nums: number[]) => nums.reduce((result, x) => result * x),
 * }
 *
 * const ret = dfs<ExprNode, null, number>(
 *   expr,
 *   (node) => node.children,
 *   null,
 *   {
 *     onLeaf(node, context) {
 *       context.returnValue = node.val
 *     },
 *     onPost(node, context) {
 *       context.returnValue = ops[node.op!](context.childReturns)
 *     },
 *   },
 * )
 * ```
 *
 * @typeParam T Node type
 * @typeParam Param Parameters type
 * @typeParam Return The return value type
 *
 * @param root The root node of a tree like object to begin search with.
 * @param children An accessor function that returns the sub-nodes if any.
 * @param param Optional parameters that can be used during traversal.
 * Give it a `null` if you don't need it.
 *
 * @returns The evaluation result of the traversal.
 */
export declare function dfs<T, Param, Return>(root: T, children: ChildrenGetter<T>, param: Param, { onPre, onPost, onIn, onLeaf }?: DfsOptions<T, Param, Return>): Return | undefined;
export declare type BfsContext = {
    cut?: boolean;
};
/**
 * Breadth first traverse a tree like object.
 *
 * @example
 * ```ts
 * type Node = {
 *   name: string
 *   checked?: boolean
 *   nodes?: Node[]
 * }
 *
 * const tree: Node = {
 *   name: "A",
 *   nodes: [
 *     {
 *       name: "B",
 *       nodes: [
 *         { name: "C" },
 *         {
 *           name: "D",
 *           checked: true,
 *           nodes: [{ name: "E", checked: true }, { name: "Z" }],
 *         },
 *       ],
 *     },
 *     {
 *       name: "F",
 *       nodes: [{ name: "G" }, { name: "H", checked: true }],
 *     },
 *   ],
 * }
 *
 * const nodes = []
 * bfs(
 *   tree,
 *   (node: any) => node.nodes,
 *   (node, context) => {
 *     if (node.checked) {
 *       nodes.push(node.name)
 *       context.cut = true
 *     }
 *   },
 * )
 * nodes // ["D", "H"]
 * ```
 *
 * @param root The tree like object to traverse to.
 * @param children The accessor function that returns the child nodes if any.
 * @param onNode Handling of the node. Return true if you want to interrupt
 * the whole traversal, or use `context.cut` to indicate you don't want to
 * go down this path.
 * @param onLevelStart This gives you an opportunity to handle depth.
 */
export declare function bfs<T>(root: T, children: ChildrenGetter<T>, onNode: (node: T, context: BfsContext, path: T[], index: number) => boolean | void, onLevelStart?: (depth: number) => boolean | void): void;
/**
 * Map a tree into a new type of tree. Becareful that the node returned by
 * `mapper` should always be a new instance.
 *
 * @example
 * ```ts
 * function map(root: Node, mapper: (node: Node, index: number) => Node) {
 *   return mapTree(
 *     root,
 *     (node) => node.children,
 *     (parent, index, node) => {
 *       parent.children[index] = node
 *     },
 *     mapper,
 *   )
 * }
 *
 * const newTree = map(tree, (node, index) => {
 *   return { ...node, val: node.val * 2 }
 * })
 * ```
 *
 * @param root The tree like object to traverse to.
 * @param children The accessor function that returns the child nodes if any.
 * @param setChild The setter function that writes to a node.
 * @param mapper Function that does the mapping work, it maps the given node
 * to a new node.
 *
 * @returns The whole mapped tree.
 */
export declare function mapTree<T, R>(root: T, children: ChildrenGetter<T>, setChild: (parent: R, index: number, node: R) => void, mapper: (node: T, index: number) => R): R | undefined;
/**
 * Filter a tree into a new filtered tree.
 *
 * @example
 * ```ts
 * function filter(root: Node, predicate: (node: Node, index: number) => boolean) {
 *   return filterTree(
 *     root,
 *     (node) => node.children,
 *     (parent, index, node) => {
 *       parent.children[index] = node
 *     },
 *     predicate,
 *   )
 * }
 *
 * const newTree = filter(tree, (node, index) => {
 *   return node.val % 2 === 0
 * })
 * ```
 *
 * @param root The tree like object to traverse to.
 * @param children The accessor function that returns the child nodes if any.
 * @param setChild The setter function that writes to a node.
 * @param predicate Function that if it returns `true`, the node will be
 * perserved, and if it returns `false`, the node will be cut from the tree.
 *
 * @returns A filtered new tree.
 */
export declare function filterTree<T>(root: T, children: ChildrenGetter<T>, setChild: (parent: T, index: number, node?: T) => void, predicate: (node: T, index: number) => boolean): T | undefined;
