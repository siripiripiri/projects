'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function stdTimezoneOffset(date) {
    var jan = new Date(date.getFullYear(), 0, 1);
    var jul = new Date(date.getFullYear(), 6, 1);
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
}
/**
 * Returns true if given `date` is DST, false otherwise.
 */
function isDst(date) {
    return date.getTimezoneOffset() < stdTimezoneOffset(date);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  };
  return __assign.apply(this, arguments);
};

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Reverse an array and return a sequence.
 */
function reverseArray(arr) {
    var i;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (arr == null)
                    return [2 /*return*/];
                i = arr.length - 1;
                _a.label = 1;
            case 1:
                if (!(i >= 0)) return [3 /*break*/, 4];
                return [4 /*yield*/, arr[i]];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3:
                i--;
                return [3 /*break*/, 1];
            case 4: return [2 /*return*/];
        }
    });
}
/**
 * Iterate a sequence in a functional style.
 */
function forEach(seq, fn) {
    var e_1, _a;
    try {
        for (var seq_1 = __values(seq), seq_1_1 = seq_1.next(); !seq_1_1.done; seq_1_1 = seq_1.next()) {
            var x = seq_1_1.value;
            fn(x);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (seq_1_1 && !seq_1_1.done && (_a = seq_1.return)) _a.call(seq_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/**
 * Map and return a new sequence.
 */
function map(seq, fn) {
    var seq_2, seq_2_1, x, e_2_1;
    var e_2, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _b.trys.push([0, 5, 6, 7]);
                seq_2 = __values(seq), seq_2_1 = seq_2.next();
                _b.label = 1;
            case 1:
                if (!!seq_2_1.done) return [3 /*break*/, 4];
                x = seq_2_1.value;
                return [4 /*yield*/, fn(x)];
            case 2:
                _b.sent();
                _b.label = 3;
            case 3:
                seq_2_1 = seq_2.next();
                return [3 /*break*/, 1];
            case 4: return [3 /*break*/, 7];
            case 5:
                e_2_1 = _b.sent();
                e_2 = { error: e_2_1 };
                return [3 /*break*/, 7];
            case 6:
                try {
                    if (seq_2_1 && !seq_2_1.done && (_a = seq_2.return)) _a.call(seq_2);
                }
                finally { if (e_2) throw e_2.error; }
                return [7 /*endfinally*/];
            case 7: return [2 /*return*/];
        }
    });
}
/**
 * Filter and return a new sequence.
 */
function filter(seq, predicate) {
    var seq_3, seq_3_1, x, e_3_1;
    var e_3, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _b.trys.push([0, 5, 6, 7]);
                seq_3 = __values(seq), seq_3_1 = seq_3.next();
                _b.label = 1;
            case 1:
                if (!!seq_3_1.done) return [3 /*break*/, 4];
                x = seq_3_1.value;
                if (!predicate(x)) return [3 /*break*/, 3];
                return [4 /*yield*/, x];
            case 2:
                _b.sent();
                _b.label = 3;
            case 3:
                seq_3_1 = seq_3.next();
                return [3 /*break*/, 1];
            case 4: return [3 /*break*/, 7];
            case 5:
                e_3_1 = _b.sent();
                e_3 = { error: e_3_1 };
                return [3 /*break*/, 7];
            case 6:
                try {
                    if (seq_3_1 && !seq_3_1.done && (_a = seq_3.return)) _a.call(seq_3);
                }
                finally { if (e_3) throw e_3.error; }
                return [7 /*endfinally*/];
            case 7: return [2 /*return*/];
        }
    });
}
/**
 * Perform reduce on a sequence.
 */
function reduce(seq, fn, initialValue) {
    var e_4, _a;
    var prev = initialValue;
    try {
        for (var seq_4 = __values(seq), seq_4_1 = seq_4.next(); !seq_4_1.done; seq_4_1 = seq_4.next()) {
            var x = seq_4_1.value;
            if (prev === undefined) {
                prev = x;
                continue;
            }
            prev = fn(prev, x);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (seq_4_1 && !seq_4_1.done && (_a = seq_4.return)) _a.call(seq_4);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return prev;
}
/**
 * Find an element in a sequence.
 */
function find(seq, predicate) {
    var e_5, _a;
    try {
        for (var seq_5 = __values(seq), seq_5_1 = seq_5.next(); !seq_5_1.done; seq_5_1 = seq_5.next()) {
            var x = seq_5_1.value;
            if (predicate(x))
                return x;
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (seq_5_1 && !seq_5_1.done && (_a = seq_5.return)) _a.call(seq_5);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return undefined;
}
/**
 * Check if an element in the sequence meets predicate.
 */
function some(seq, predicate) {
    var e_6, _a;
    try {
        for (var seq_6 = __values(seq), seq_6_1 = seq_6.next(); !seq_6_1.done; seq_6_1 = seq_6.next()) {
            var x = seq_6_1.value;
            if (predicate(x))
                return true;
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (seq_6_1 && !seq_6_1.done && (_a = seq_6.return)) _a.call(seq_6);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return false;
}
/**
 * Check if all elements in the sequence meet predicate.
 */
function every(seq, predicate) {
    var e_7, _a;
    try {
        for (var seq_7 = __values(seq), seq_7_1 = seq_7.next(); !seq_7_1.done; seq_7_1 = seq_7.next()) {
            var x = seq_7_1.value;
            if (!predicate(x))
                return false;
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (seq_7_1 && !seq_7_1.done && (_a = seq_7.return)) _a.call(seq_7);
        }
        finally { if (e_7) throw e_7.error; }
    }
    return true;
}
/**
 * Find the first minimum element in the given sequence.
 * You need to provide a accessor `by` for the comparison purpose.
 */
function min(seq, by) {
    var e_8, _a;
    var ret;
    try {
        for (var seq_8 = __values(seq), seq_8_1 = seq_8.next(); !seq_8_1.done; seq_8_1 = seq_8.next()) {
            var x = seq_8_1.value;
            if (ret === undefined || by(x) < by(ret)) {
                ret = x;
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (seq_8_1 && !seq_8_1.done && (_a = seq_8.return)) _a.call(seq_8);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return ret;
}
/**
 * Find the first maximum element in the given sequence.
 * You need to provide a accessor `by` for the comparison purpose.
 */
function max(seq, by) {
    var e_9, _a;
    var ret;
    try {
        for (var seq_9 = __values(seq), seq_9_1 = seq_9.next(); !seq_9_1.done; seq_9_1 = seq_9.next()) {
            var x = seq_9_1.value;
            if (ret === undefined || by(x) > by(ret)) {
                ret = x;
            }
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (seq_9_1 && !seq_9_1.done && (_a = seq_9.return)) _a.call(seq_9);
        }
        finally { if (e_9) throw e_9.error; }
    }
    return ret;
}

var Node$1 = /** @class */ (function () {
    function Node(val, prev, next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
    return Node;
}());
/**
 * A doubly-linked list.
 *
 * ```ts
 * const list = new DLinkedList<number>()
 * list.push(2)
 * list.unshift(1)
 * list.append([3, 4])
 * list
 *   .filter((num) => n % 2 === 0)
 *   .map((num) => n * 2)
 *   .forEach((num) => console.log(num))
 * ```
 */
var DLinkedList = /** @class */ (function () {
    function DLinkedList() {
        this._length = 0;
    }
    Object.defineProperty(DLinkedList.prototype, "length", {
        /**
         * Number of elements in the list.
         */
        get: function () {
            return this._length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Pop an element from the start of the list.
     */
    DLinkedList.prototype.shift = function () {
        var first = this.first;
        if (first === undefined)
            return undefined;
        this._length--;
        if (first.next === undefined) {
            this.last = undefined;
        }
        else {
            first.next.prev = undefined;
        }
        this.first = first.next;
        first.next = undefined;
        return first.val;
    };
    /**
     * Pop an element from the end of the list.
     */
    DLinkedList.prototype.pop = function () {
        var last = this.last;
        if (last === undefined)
            return undefined;
        this._length--;
        if (last.prev === undefined) {
            this.first = undefined;
        }
        else {
            last.prev.next = undefined;
        }
        this.last = last.prev;
        last.prev = undefined;
        return last.val;
    };
    /**
     * Push an element to the start of the list.
     *
     * @param val Element to push.
     */
    DLinkedList.prototype.unshift = function (val) {
        var node = new Node$1(val);
        var first = this.first;
        if (first === undefined) {
            this.last = node;
        }
        else {
            node.next = first;
            first.prev = node;
        }
        this.first = node;
        this._length++;
    };
    /**
     * Push an element to the end of the list.
     *
     * @param val Element to push.
     */
    DLinkedList.prototype.push = function (val) {
        var node = new Node$1(val);
        var last = this.last;
        if (last === undefined) {
            this.first = node;
        }
        else {
            last.next = node;
            node.prev = last;
        }
        this.last = node;
        this._length++;
    };
    /**
     * Push a sequence of elements to the start of the list.
     *
     * @param vals Elements to push.
     */
    DLinkedList.prototype.prepend = function (vals) {
        var e_1, _a;
        var node;
        var curr;
        var count = 0;
        try {
            for (var vals_1 = __values(vals), vals_1_1 = vals_1.next(); !vals_1_1.done; vals_1_1 = vals_1.next()) {
                var val = vals_1_1.value;
                count++;
                if (node === undefined) {
                    node = new Node$1(val);
                    curr = node;
                    continue;
                }
                var newNode = new Node$1(val);
                curr.next = newNode;
                newNode.prev = curr;
                curr = newNode;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vals_1_1 && !vals_1_1.done && (_a = vals_1.return)) _a.call(vals_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var first = this.first;
        if (curr !== undefined) {
            curr.next = first;
            if (first !== undefined) {
                first.prev = curr;
            }
        }
        if (node !== undefined) {
            this.first = node;
        }
        this._length += count;
    };
    /**
     * Push a sequence of elements to the end of the list.
     *
     * @param vals Elements to push.
     */
    DLinkedList.prototype.append = function (vals) {
        var e_2, _a;
        var node;
        var curr;
        var count = 0;
        try {
            for (var vals_2 = __values(vals), vals_2_1 = vals_2.next(); !vals_2_1.done; vals_2_1 = vals_2.next()) {
                var val = vals_2_1.value;
                count++;
                if (node === undefined) {
                    node = new Node$1(val);
                    curr = node;
                    continue;
                }
                var newNode = new Node$1(val);
                curr.next = newNode;
                newNode.prev = curr;
                curr = newNode;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (vals_2_1 && !vals_2_1.done && (_a = vals_2.return)) _a.call(vals_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var last = this.last;
        if (last === undefined) {
            this.first = node;
        }
        else {
            last.next = node;
            if (node !== undefined) {
                node.prev = last;
            }
        }
        this.last = node;
        this._length += count;
    };
    /**
     * Empty the list.
     */
    DLinkedList.prototype.clear = function () {
        this.first = undefined;
        this.last = undefined;
        this._length = 0;
    };
    /**
     * Make instance iterable.
     */
    DLinkedList.prototype[Symbol.iterator] = function () {
        var cur = this.first;
        return {
            next: function () {
                if (cur === undefined) {
                    return {
                        done: true,
                        value: undefined,
                    };
                }
                else {
                    var ret = {
                        done: false,
                        value: cur.val,
                    };
                    cur = cur.next;
                    return ret;
                }
            },
        };
    };
    /**
     * Iterate through the list.
     */
    DLinkedList.prototype.forEach = function (fn) {
        forEach(this, fn);
    };
    /**
     * Map the list elements.
     *
     * @returns A new list instance.
     */
    DLinkedList.prototype.map = function (fn) {
        var e_3, _a;
        var newList = new DLinkedList();
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var x = _c.value;
                newList.push(fn(x));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return newList;
    };
    /**
     * Filter the list.
     *
     * @returns A new list instance.
     */
    DLinkedList.prototype.filter = function (predicate) {
        var e_4, _a;
        var newList = new DLinkedList();
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var x = _c.value;
                if (predicate(x)) {
                    newList.push(x);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return newList;
    };
    /**
     * Perform reduce on the list.
     *
     * @returns The reduced value.
     */
    DLinkedList.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue);
    };
    /**
     * Find a specific element in the list.
     *
     * @returns Element found or `undefined` otherwise.
     */
    DLinkedList.prototype.find = function (predicate) {
        return find(this, predicate);
    };
    /**
     * Check if at least one element meets the predicate.
     */
    DLinkedList.prototype.some = function (predicate) {
        return some(this, predicate);
    };
    /**
     * Check if all elements meet the predicate.
     */
    DLinkedList.prototype.every = function (predicate) {
        return every(this, predicate);
    };
    DLinkedList.prototype.toString = function () {
        return "DLinkedList:".concat(Array.from(this));
    };
    return DLinkedList;
}());

/**
 * A doubly-ended queue.
 *
 * ```ts
 * const queue = new Deque<number>()
 * queue.push(3)
 * queue.push(4)
 * queue.unshift(2)
 * queue.unshift(1)
 * queue.shift() // 1
 * queue.pop() // 4
 * ```
 */
var Deque = /** @class */ (function () {
    function Deque() {
        this._list = new DLinkedList();
    }
    Object.defineProperty(Deque.prototype, "length", {
        /**
         * Number of elements in the queue.
         */
        get: function () {
            return this._list.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Preview the element to shift next.
     */
    Deque.prototype.peekStart = function () {
        var _a;
        return (_a = this._list.first) === null || _a === void 0 ? void 0 : _a.val;
    };
    /**
     * Preview the element to pop next.
     */
    Deque.prototype.peekEnd = function () {
        var _a;
        return (_a = this._list.last) === null || _a === void 0 ? void 0 : _a.val;
    };
    /**
     * Push an element to the end of the queue.
     *
     * @param val Element to push.
     */
    Deque.prototype.push = function (val) {
        this._list.push(val);
    };
    /**
     * Pop an element from the end of the queue.
     */
    Deque.prototype.pop = function () {
        return this._list.pop();
    };
    /**
     * Push an element to the start of the queue.
     *
     * @param val Element to push.
     */
    Deque.prototype.unshift = function (val) {
        this._list.unshift(val);
    };
    /**
     * Pop an element from the start of the queue.
     */
    Deque.prototype.shift = function () {
        return this._list.shift();
    };
    return Deque;
}());

/**
 * MaxHeap
 */
var MaxHeap = /** @class */ (function () {
    /**
     * Make an instance of MaxHeap.
     *
     * @param accessor Accessor function that gives the number to sort to.
     */
    function MaxHeap(accessor) {
        if (accessor === void 0) { accessor = function (x) { return x; }; }
        this._data = [];
        this._accessor = accessor;
    }
    Object.defineProperty(MaxHeap.prototype, "length", {
        /**
         * Number of elements in the heap.
         */
        get: function () {
            return this._data.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Preview the root value.
     */
    MaxHeap.prototype.peek = function () {
        return this._data[0];
    };
    /**
     * Push a value onto the heap/
     */
    MaxHeap.prototype.push = function (val) {
        var _a;
        var data = this._data;
        var accessor = this._accessor;
        data.push(val);
        var me = data.length - 1;
        var parent = ((me - 1) / 2) >> 0;
        while (me > 0 && accessor(data[me]) > accessor(data[parent])) {
            _a = __read([data[me], data[parent]], 2), data[parent] = _a[0], data[me] = _a[1];
            me = parent;
            parent = ((me - 1) / 2) >> 0;
        }
    };
    /**
     * Pop the root value.
     */
    MaxHeap.prototype.pop = function () {
        var _a;
        var _b, _c, _d, _e, _f, _g;
        var data = this._data;
        if (data.length <= 1)
            return data.pop();
        var accessor = this._accessor;
        var toPop = data[0];
        data[0] = data.pop();
        var me = 0;
        var left = 2 * me + 1;
        var right = 2 * me + 2;
        var leftVal = (_b = accessor(data[left])) !== null && _b !== void 0 ? _b : -Infinity;
        var rightVal = (_c = accessor(data[right])) !== null && _c !== void 0 ? _c : -Infinity;
        var child = rightVal > leftVal ? right : left;
        var childVal = (_d = accessor(data[child])) !== null && _d !== void 0 ? _d : -Infinity;
        while (childVal > accessor(data[me])) {
            _a = __read([data[me], data[child]], 2), data[child] = _a[0], data[me] = _a[1];
            me = child;
            left = 2 * me + 1;
            right = 2 * me + 2;
            leftVal = (_e = accessor(data[left])) !== null && _e !== void 0 ? _e : -Infinity;
            rightVal = (_f = accessor(data[right])) !== null && _f !== void 0 ? _f : -Infinity;
            child = rightVal > leftVal ? right : left;
            childVal = (_g = accessor(data[child])) !== null && _g !== void 0 ? _g : -Infinity;
        }
        return toPop;
    };
    return MaxHeap;
}());
/**
 * MinHeap
 */
var MinHeap = /** @class */ (function () {
    /**
     * Make an instance of MinHeap.
     *
     * @param accessor Accessor function that gives the number to sort to.
     */
    function MinHeap(accessor) {
        if (accessor === void 0) { accessor = function (x) { return x; }; }
        this._data = [];
        this._accessor = accessor;
    }
    Object.defineProperty(MinHeap.prototype, "length", {
        /**
         * Number of elements in the heap.
         */
        get: function () {
            return this._data.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Preview the root value.
     */
    MinHeap.prototype.peek = function () {
        return this._data[0];
    };
    /**
     * Push a value onto the heap/
     */
    MinHeap.prototype.push = function (val) {
        var _a;
        var data = this._data;
        data.push(val);
        var accessor = this._accessor;
        var me = data.length - 1;
        var parent = ((me - 1) / 2) >> 0;
        while (me > 0 && accessor(data[me]) < accessor(data[parent])) {
            _a = __read([data[me], data[parent]], 2), data[parent] = _a[0], data[me] = _a[1];
            me = parent;
            parent = ((me - 1) / 2) >> 0;
        }
    };
    /**
     * Pop the root value.
     */
    MinHeap.prototype.pop = function () {
        var _a;
        var _b, _c, _d, _e, _f, _g;
        var data = this._data;
        if (data.length <= 1)
            return data.pop();
        var accessor = this._accessor;
        var toPop = data[0];
        data[0] = data.pop();
        var me = 0;
        var left = 2 * me + 1;
        var right = 2 * me + 2;
        var leftVal = (_b = accessor(data[left])) !== null && _b !== void 0 ? _b : Infinity;
        var rightVal = (_c = accessor(data[right])) !== null && _c !== void 0 ? _c : Infinity;
        var child = rightVal < leftVal ? right : left;
        var childVal = (_d = accessor(data[child])) !== null && _d !== void 0 ? _d : Infinity;
        while (childVal < accessor(data[me])) {
            _a = __read([data[me], data[child]], 2), data[child] = _a[0], data[me] = _a[1];
            me = child;
            left = 2 * me + 1;
            right = 2 * me + 2;
            leftVal = (_e = accessor(data[left])) !== null && _e !== void 0 ? _e : Infinity;
            rightVal = (_f = accessor(data[right])) !== null && _f !== void 0 ? _f : Infinity;
            child = rightVal > leftVal ? right : left;
            childVal = (_g = accessor(data[child])) !== null && _g !== void 0 ? _g : Infinity;
        }
        return toPop;
    };
    return MinHeap;
}());

var Node = /** @class */ (function () {
    function Node(val, next) {
        this.val = val;
        this.next = next;
    }
    return Node;
}());
/**
 * A singlely-linked list.
 *
 * ```ts
 * const list = new LinkedList<number>()
 * list.push(1)
 * list.append([2, 3])
 * list
 *   .filter((num) => n % 2 !== 0)
 *   .map((num) => n * 2)
 *   .forEach((num) => console.log(num))
 * ```
 */
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        this._length = 0;
    }
    Object.defineProperty(LinkedList.prototype, "length", {
        /**
         * Number of elements in the queue.
         */
        get: function () {
            return this._length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Pop an element from the start of the list.
     */
    LinkedList.prototype.shift = function () {
        var first = this.first;
        if (first === undefined)
            return undefined;
        this._length--;
        if (first.next === undefined) {
            this.last = undefined;
        }
        this.first = first.next;
        first.next = undefined;
        return first.val;
    };
    /**
     * Push an element to the start of the list.
     *
     * @param val Element to push.
     */
    LinkedList.prototype.unshift = function (val) {
        var node = new Node(val);
        var first = this.first;
        if (first === undefined) {
            this.last = node;
        }
        else {
            node.next = first;
        }
        this.first = node;
        this._length++;
    };
    /**
     * Push an element to the end of the list.
     *
     * @param val Element to push.
     */
    LinkedList.prototype.push = function (val) {
        var node = new Node(val);
        var last = this.last;
        if (last === undefined) {
            this.first = node;
        }
        else {
            last.next = node;
        }
        this.last = node;
        this._length++;
    };
    /**
     * Push a sequence of elements to the start of the list.
     *
     * @param vals Elements to push.
     */
    LinkedList.prototype.prepend = function (vals) {
        var e_1, _a;
        var node;
        var curr;
        var count = 0;
        try {
            for (var vals_1 = __values(vals), vals_1_1 = vals_1.next(); !vals_1_1.done; vals_1_1 = vals_1.next()) {
                var val = vals_1_1.value;
                count++;
                if (node === undefined) {
                    node = new Node(val);
                    curr = node;
                    continue;
                }
                var newNode = new Node(val);
                curr.next = newNode;
                curr = newNode;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vals_1_1 && !vals_1_1.done && (_a = vals_1.return)) _a.call(vals_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (curr !== undefined) {
            curr.next = this.first;
        }
        if (node !== undefined) {
            this.first = node;
        }
        this._length += count;
    };
    /**
     * Push a sequence of elements to the end of the list.
     *
     * @param vals Elements to push.
     */
    LinkedList.prototype.append = function (vals) {
        var e_2, _a;
        var node;
        var curr;
        var count = 0;
        try {
            for (var vals_2 = __values(vals), vals_2_1 = vals_2.next(); !vals_2_1.done; vals_2_1 = vals_2.next()) {
                var val = vals_2_1.value;
                count++;
                if (node === undefined) {
                    node = new Node(val);
                    curr = node;
                    continue;
                }
                var newNode = new Node(val);
                curr.next = newNode;
                curr = newNode;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (vals_2_1 && !vals_2_1.done && (_a = vals_2.return)) _a.call(vals_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var last = this.last;
        if (last === undefined) {
            this.first = node;
        }
        else {
            last.next = node;
        }
        this.last = node;
        this._length += count;
    };
    /**
     * Empty the list.
     */
    LinkedList.prototype.clear = function () {
        this.first = undefined;
        this.last = undefined;
        this._length = 0;
    };
    /**
     * Make instance iterable.
     */
    LinkedList.prototype[Symbol.iterator] = function () {
        var cur = this.first;
        return {
            next: function () {
                if (cur === undefined) {
                    return {
                        done: true,
                        value: undefined,
                    };
                }
                else {
                    var ret = {
                        done: false,
                        value: cur.val,
                    };
                    cur = cur.next;
                    return ret;
                }
            },
        };
    };
    /**
     * Iterate through the list.
     */
    LinkedList.prototype.forEach = function (fn) {
        forEach(this, fn);
    };
    /**
     * Map the list elements.
     *
     * @returns A new list instance.
     */
    LinkedList.prototype.map = function (fn) {
        var e_3, _a;
        var newList = new LinkedList();
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var x = _c.value;
                newList.push(fn(x));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return newList;
    };
    /**
     * Filter the list.
     *
     * @returns A new list instance.
     */
    LinkedList.prototype.filter = function (predicate) {
        var e_4, _a;
        var newList = new LinkedList();
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var x = _c.value;
                if (predicate(x)) {
                    newList.push(x);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return newList;
    };
    /**
     * Perform reduce on the list.
     *
     * @returns The reduced value.
     */
    LinkedList.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue);
    };
    /**
     * Find a specific element in the list.
     *
     * @returns Element found or `undefined` otherwise.
     */
    LinkedList.prototype.find = function (predicate) {
        return find(this, predicate);
    };
    /**
     * Check if at least one element meets the predicate.
     */
    LinkedList.prototype.some = function (predicate) {
        return some(this, predicate);
    };
    /**
     * Check if all elements meet the predicate.
     */
    LinkedList.prototype.every = function (predicate) {
        return every(this, predicate);
    };
    LinkedList.prototype.toString = function () {
        return "LinkedList:".concat(Array.from(this));
    };
    return LinkedList;
}());

/**
 * Returns random integers between from and to inclusive. from and to can be negative.
 */
function randomInt(from, to) {
    var start = from >> 0;
    var end = to >> 0;
    return ((Math.random() * (end - start + 1)) >> 0) + start;
}
/**
 * Real modulo operation that supports negative numbers.
 *
 * ```ts
 * mod(1, 3) // 1
 * mod(-1, 3) // 2
 * ```
 */
function mod(x, y) {
    return ((x % y) + y) % y;
}
/**
 * Returns a promise that wait for ms milliseconds.
 */
function waitMs(ms) {
    return new Promise(function (resolve) { return setTimeout(resolve, ms); });
}

/**
 * A proper queue implemented using a linked list.
 */
var Queue = /** @class */ (function () {
    /**
     * Create a new queue with an optional initial element.
     *
     * @param initial Optional initial element.
     */
    function Queue(initial) {
        this._list = new LinkedList();
        if (initial !== undefined) {
            this._list.push(initial);
        }
    }
    Object.defineProperty(Queue.prototype, "length", {
        /**
         * Number of elements in the queue.
         */
        get: function () {
            return this._list.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Preview the element to pop next.
     */
    Queue.prototype.peek = function () {
        var _a;
        return (_a = this._list.first) === null || _a === void 0 ? void 0 : _a.val;
    };
    /**
     * Push an element onto the queue.
     *
     * @param val Element to push.
     */
    Queue.prototype.push = function (val) {
        this._list.push(val);
    };
    /**
     * Pop an element from the queue.
     */
    Queue.prototype.pop = function () {
        return this._list.shift();
    };
    /**
     * Pop all the elements left in the queue into an array.
     *
     * @returns An array of the elements.
     */
    Queue.prototype.popAll = function () {
        var result = Array.from(this._list);
        this._list = new LinkedList();
        return result;
    };
    /**
     * Push all elements given.
     *
     * @param vals An iterable of elements to push.
     */
    Queue.prototype.pushAll = function (vals) {
        this._list.append(vals);
    };
    return Queue;
}());

var PriorityQueue = /** @class */ (function () {
    function PriorityQueue() {
        this._data = new Map();
        this._length = 0;
    }
    Object.defineProperty(PriorityQueue.prototype, "length", {
        /**
         * Number of elements in the queue.
         */
        get: function () {
            return this._length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Push an element onto the queue.
     *
     * @param priority Priority of the element.
     * @param val Element to push.
     */
    PriorityQueue.prototype.push = function (priority, val) {
        var data = this._data;
        if (!data.has(priority)) {
            data.set(priority, new Queue());
            this._priorities.push(priority);
        }
        var list = data.get(priority);
        list.push(val);
        this._length++;
    };
    /**
     * Pop an element from the queue.
     */
    PriorityQueue.prototype.pop = function () {
        var data = this._data;
        var priorities = this._priorities;
        var priority = priorities.peek();
        if (!priority)
            return undefined;
        var list = data.get(priority);
        var val = list.pop();
        if (list.length < 1) {
            priorities.pop();
            data.delete(priority);
        }
        this._length--;
        return val;
    };
    /**
     * Preview the element to pop next.
     */
    PriorityQueue.prototype.peek = function () {
        var data = this._data;
        var priorities = this._priorities;
        var priority = priorities.peek();
        if (!priority)
            return undefined;
        var list = data.get(priority);
        return list.peek();
    };
    /**
     * Preview the next priority number.
     */
    PriorityQueue.prototype.peekPriority = function () {
        return this._priorities.peek();
    };
    return PriorityQueue;
}());
/**
 * A priority queue where bigger numbers have higher
 * priorities.
 *
 * ```ts
 * const queue = new MaxPriorityQueue<string>()
 * queue.push(1, "1")
 * queue.push(2, "2")
 * queue.pop() // "2"
 * ```
 */
var MaxPriorityQueue = /** @class */ (function (_super) {
    __extends(MaxPriorityQueue, _super);
    function MaxPriorityQueue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._priorities = new MaxHeap();
        return _this;
    }
    return MaxPriorityQueue;
}(PriorityQueue));
/**
 * A priority queue where smaller numbers have higher
 * priorities.
 *
 * ```ts
 * const queue = new MinPriorityQueue<string>()
 * queue.push(1, "1")
 * queue.push(2, "2")
 * queue.push(0, "0")
 * queue.pop() // "0"
 * ```
 */
var MinPriorityQueue = /** @class */ (function (_super) {
    __extends(MinPriorityQueue, _super);
    function MinPriorityQueue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._priorities = new MinHeap();
        return _this;
    }
    return MinPriorityQueue;
}(PriorityQueue));

/**
 * A proper stack implemented using a linked list.
 */
var Stack = /** @class */ (function () {
    /**
     * Create a new stack with an optional initial element.
     *
     * @param initial Optional initial element.
     */
    function Stack(initial) {
        this._list = new LinkedList();
        if (initial !== undefined) {
            this._list.unshift(initial);
        }
    }
    Object.defineProperty(Stack.prototype, "length", {
        /**
         * Number of elements in the queue.
         */
        get: function () {
            return this._list.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Preview the element to pop next.
     */
    Stack.prototype.peek = function () {
        var _a;
        return (_a = this._list.first) === null || _a === void 0 ? void 0 : _a.val;
    };
    /**
     * Push an element to the stack.
     *
     * @param val Element to push.
     */
    Stack.prototype.push = function (val) {
        this._list.unshift(val);
    };
    /**
     * Pop an element from the stack.
     */
    Stack.prototype.pop = function () {
        return this._list.shift();
    };
    /**
     * Pop all the elements left in the stack into an array.
     *
     * @returns An array of the elements.
     */
    Stack.prototype.popAll = function () {
        var result = Array.from(this._list);
        this._list = new LinkedList();
        return result;
    };
    /**
     * Push all elements given in an optional specific order.
     *
     * @param vals An array of elements to push.
     * @param reversed Push the elements in reversed order.
     */
    Stack.prototype.pushAll = function (vals, reversed) {
        if (reversed === void 0) { reversed = false; }
        if (reversed) {
            this._list.prepend(vals);
        }
        else {
            this._list.prepend(reverseArray(vals));
        }
    };
    return Stack;
}());

var Context = /** @class */ (function () {
    function Context(param, locals) {
        this.param = param;
        this.locals = locals;
    }
    return Context;
}());
var ITEM = 0;
var FRAME = 1;
var Item = /** @class */ (function () {
    function Item(param, type) {
        this.param = param;
        this.type = type;
    }
    return Item;
}());
/**
 * It implements an iterative execution of the given recursion. That is,
 * you write an algorithm in a recursive way, but you get an iterative
 * execution of it.
 *
 * The running is divided into 2 phases. In `start` phase, you write
 * everything that runs before recursions, you also specify recursions
 * you want to run here; In `consume` phase, you consume all the recursive
 * calls' returns.
 *
 * **NOTE:** Because it has only 2 phases, it can't support all kinds
 * of recursion usage, for more complex usages you can use {@link recurse}.
 * For simpler ones however, this function is faster.
 *
 * @example
 * ```ts
 * function factorial(n: number) {
 *   return rec2iter(
 *     (n, context) => {
 *       if (n <= 1) return 1
 *       context.recursions = [n - 1]
 *     },
 *     (n, [fac_n_minus_1]) => n * fac_n_minus_1,
 *     n,
 *   )
 * }
 * ```
 *
 * @param start The start phase where you write everything that runs before
 * recursive calls. You also specify what recursions you want to run next
 * here.
 * @param consume The consume phase where you can get all recursive calls'
 * return values.
 * @param param The initial parameters to kick off the recursion.
 *
 * @returns The result of the whole recursion.
 */
function rec2iter(start, consume, param) {
    var _a, _b;
    var stack = new Stack(new Item(param, FRAME));
    var contextStack = new Stack(new Context(param));
    while (stack.length > 0) {
        var _c = stack.pop(), param_1 = _c.param, type = _c.type;
        if (type === FRAME) {
            var startContext = {};
            var v = start(param_1, startContext);
            if ((_a = startContext.recursions) === null || _a === void 0 ? void 0 : _a.length) {
                contextStack.push(new Context(param_1, startContext.locals));
                stack.push(new Item(param_1, ITEM));
                stack.pushAll(startContext.recursions.map(function (recursionParam) { return new Item(recursionParam, FRAME); }), true);
            }
            else {
                var context = contextStack.peek();
                if (context.returns === undefined) {
                    context.returns = [];
                }
                context.returns.push(v);
            }
        } /* type === ITEM */
        else {
            var _d = contextStack.pop(), param_2 = _d.param, returns = _d.returns, locals = _d.locals;
            var ret = consume(param_2, returns, locals);
            if (ret !== undefined) {
                var context = contextStack.peek();
                if (context.returns === undefined) {
                    context.returns = [];
                }
                context.returns.push(ret);
            }
        }
    }
    return (_b = contextStack.pop().returns) === null || _b === void 0 ? void 0 : _b.pop();
}
/**
 * It implements an iterative execution of the given recursion. That is,
 * you write an algorithm in a recursive way, but you get an iterative
 * execution of it.
 *
 * @example
 * ```ts
 * function factorial(n: number) {
 *   return recurse<number, number>(function* (n) {
 *     if (n <= 1) return 1
 *     return n * (yield n - 1)
 *   }, n)
 * }
 * ```
 *
 * @param body A generator function working as the main body for recursion,
 * it yields recursions.
 * @param initialParam Initial parameter.
 */
function recurse(body, initialParam) {
    var stack = new Stack([
        initialParam,
        null,
    ]);
    var contextStack = new Stack();
    while (stack.length > 0) {
        var _a = __read(stack.pop(), 2), param = _a[0], control = _a[1];
        if (control === null) {
            var control_1 = body(param);
            var _b = control_1.next(), value = _b.value, done = _b.done;
            if (!done) {
                // has more recursions to do.
                stack.push([param, control_1]);
                stack.push([value, null]);
            }
            else {
                contextStack.push(value);
            }
        }
        else {
            var returns = contextStack.peek();
            var _c = control.next(returns), value = _c.value, done = _c.done;
            if (!done) {
                // has more recursions to do.
                stack.push([param, control]);
                stack.push([value, null]);
            }
            else {
                contextStack.pop();
                if (value !== undefined) {
                    contextStack.push(value);
                }
            }
        }
    }
    return contextStack.pop();
}

/**
 * Returns a new set that is the union of all given sets.
 */
function union() {
    var e_1, _a, e_2, _b;
    var sets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sets[_i] = arguments[_i];
    }
    var ret = new Set();
    try {
        for (var sets_1 = __values(sets), sets_1_1 = sets_1.next(); !sets_1_1.done; sets_1_1 = sets_1.next()) {
            var set = sets_1_1.value;
            try {
                for (var set_1 = (e_2 = void 0, __values(set)), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {
                    var x = set_1_1.value;
                    ret.add(x);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (set_1_1 && !set_1_1.done && (_b = set_1.return)) _b.call(set_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sets_1_1 && !sets_1_1.done && (_a = sets_1.return)) _a.call(sets_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return ret;
}
/**
 * Returns a new set that is the intersection of all given sets.
 */
function intersection() {
    var e_3, _a;
    var _b;
    var sets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sets[_i] = arguments[_i];
    }
    var ret = new Set();
    var smallestSet = (_b = min(sets, function (x) { return x.size; })) !== null && _b !== void 0 ? _b : new Set();
    var _loop_1 = function (x) {
        if (sets.every(function (s) { return s.has(x); })) {
            ret.add(x);
        }
    };
    try {
        for (var smallestSet_1 = __values(smallestSet), smallestSet_1_1 = smallestSet_1.next(); !smallestSet_1_1.done; smallestSet_1_1 = smallestSet_1.next()) {
            var x = smallestSet_1_1.value;
            _loop_1(x);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (smallestSet_1_1 && !smallestSet_1_1.done && (_a = smallestSet_1.return)) _a.call(smallestSet_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return ret;
}
/**
 * Returns a new set that is the difference of the given sets in sequence.
 */
function diff() {
    var sets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sets[_i] = arguments[_i];
    }
    return reduce(sets, function (a, b) {
        var e_4, _a;
        var ret = new Set();
        try {
            for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {
                var x = a_1_1.value;
                if (!b.has(x)) {
                    ret.add(x);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return ret;
    });
}

/**
 * Context of the current non-leaf node.
 */
var TraversalContext = /** @class */ (function () {
    function TraversalContext(param) {
        this.param = param;
        this.locals = {};
        this.childReturns = [];
    }
    return TraversalContext;
}());
var NODE = 0;
var LEAF = 1;
var PRE = 2;
var IN = 3;
var POST = 4;
var DfsNode = /** @class */ (function () {
    function DfsNode(node, index, type) {
        this.node = node;
        this.index = index;
        this.type = type;
    }
    return DfsNode;
}());
/**
 * This is a general and efficient iterative version of depth first
 * search/traversal.
 *
 * @example
 * ```ts
 * type ExprNode = {
 *   op?: "+" | "-" | "*"
 *   val?: number
 *   children?: ExprNode[]
 * }
 *
 * const expr: ExprNode = {
 *   op: "+",
 *   children: [
 *     {
 *       op: "*",
 *       children: [{ val: 3 }, { val: 4 }, { val: 1 }],
 *     },
 *     {
 *       op: "-",
 *       children: [{ val: 7 }, { val: 3 }],
 *     },
 *   ],
 * }
 *
 * const ops = {
 *   "+": (nums: number[]) => nums.reduce((result, x) => result + x),
 *   "-": (nums: number[]) => nums.reduce((result, x) => result - x),
 *   "*": (nums: number[]) => nums.reduce((result, x) => result * x),
 * }
 *
 * const ret = dfs<ExprNode, null, number>(
 *   expr,
 *   (node) => node.children,
 *   null,
 *   {
 *     onLeaf(node, context) {
 *       context.returnValue = node.val
 *     },
 *     onPost(node, context) {
 *       context.returnValue = ops[node.op!](context.childReturns)
 *     },
 *   },
 * )
 * ```
 *
 * @typeParam T Node type
 * @typeParam Param Parameters type
 * @typeParam Return The return value type
 *
 * @param root The root node of a tree like object to begin search with.
 * @param children An accessor function that returns the sub-nodes if any.
 * @param param Optional parameters that can be used during traversal.
 * Give it a `null` if you don't need it.
 *
 * @returns The evaluation result of the traversal.
 */
function dfs(root, children, param, _a) {
    var _b, _c, _d;
    var _e = _a === void 0 ? {} : _a, onPre = _e.onPre, onPost = _e.onPost, onIn = _e.onIn, onLeaf = _e.onLeaf;
    var nodeStack = new Stack(new DfsNode(root, 0, ((_b = children(root)) === null || _b === void 0 ? void 0 : _b.length) ? NODE : LEAF));
    var contextStack = new Stack(new TraversalContext(param));
    while (nodeStack.length > 0) {
        var _f = nodeStack.pop(), node = _f.node, index = _f.index, type = _f.type;
        if (type === NODE) {
            nodeStack.push(new DfsNode(node, index, POST));
            var subnodes = children(node);
            var len = subnodes.length;
            var half = (subnodes.length / 2) >> 0;
            for (var i = len - 1; i >= half; i--) {
                var subnode = subnodes[i];
                nodeStack.push(new DfsNode(subnode, i, ((_c = children(subnode)) === null || _c === void 0 ? void 0 : _c.length) ? NODE : LEAF));
            }
            nodeStack.push(new DfsNode(node, index, IN));
            for (var i = half - 1; i >= 0; i--) {
                var subnode = subnodes[i];
                nodeStack.push(new DfsNode(subnode, i, ((_d = children(subnode)) === null || _d === void 0 ? void 0 : _d.length) ? NODE : LEAF));
            }
            nodeStack.push(new DfsNode(node, index, PRE));
        }
        else if (type === PRE) {
            contextStack.push(new TraversalContext(contextStack.peek().param));
            if (!onPre)
                continue;
            var context = contextStack.peek();
            var interrupt = onPre(node, context, index);
            if (context.returnValue !== undefined) {
                contextStack.peek().childReturns.push(context.returnValue);
            }
            if (interrupt)
                break;
        }
        else if (type === IN) {
            if (!onIn)
                continue;
            var context = contextStack.peek();
            var interrupt = onIn(node, context, index);
            if (context.returnValue !== undefined) {
                contextStack.peek().childReturns.push(context.returnValue);
            }
            if (interrupt)
                break;
        }
        else if (type === POST) {
            var context = contextStack.pop();
            if (!onPost)
                continue;
            var interrupt = onPost(node, context, index);
            if (context.returnValue !== undefined) {
                contextStack.peek().childReturns.push(context.returnValue);
            }
            if (interrupt)
                break;
        }
        else if (type === LEAF) {
            if (!onLeaf)
                continue;
            var context = new TraversalContext(contextStack.peek().param);
            var interrupt = onLeaf(node, context, index);
            if (context.returnValue !== undefined) {
                contextStack.peek().childReturns.push(context.returnValue);
            }
            if (interrupt)
                break;
        }
    }
    return contextStack.pop().childReturns.pop();
}
var BfsNode = /** @class */ (function () {
    function BfsNode(node, path, index) {
        this.node = node;
        this.path = path;
        this.index = index;
    }
    return BfsNode;
}());
/**
 * Breadth first traverse a tree like object.
 *
 * @example
 * ```ts
 * type Node = {
 *   name: string
 *   checked?: boolean
 *   nodes?: Node[]
 * }
 *
 * const tree: Node = {
 *   name: "A",
 *   nodes: [
 *     {
 *       name: "B",
 *       nodes: [
 *         { name: "C" },
 *         {
 *           name: "D",
 *           checked: true,
 *           nodes: [{ name: "E", checked: true }, { name: "Z" }],
 *         },
 *       ],
 *     },
 *     {
 *       name: "F",
 *       nodes: [{ name: "G" }, { name: "H", checked: true }],
 *     },
 *   ],
 * }
 *
 * const nodes = []
 * bfs(
 *   tree,
 *   (node: any) => node.nodes,
 *   (node, context) => {
 *     if (node.checked) {
 *       nodes.push(node.name)
 *       context.cut = true
 *     }
 *   },
 * )
 * nodes // ["D", "H"]
 * ```
 *
 * @param root The tree like object to traverse to.
 * @param children The accessor function that returns the child nodes if any.
 * @param onNode Handling of the node. Return true if you want to interrupt
 * the whole traversal, or use `context.cut` to indicate you don't want to
 * go down this path.
 * @param onLevelStart This gives you an opportunity to handle depth.
 */
function bfs(root, children, onNode, onLevelStart) {
    var depth = 0;
    var queue = new Queue(new BfsNode(root, [], 0));
    while (queue.length > 0) {
        var len = queue.length;
        if (onLevelStart === null || onLevelStart === void 0 ? void 0 : onLevelStart(depth))
            return;
        for (var i = 0; i < len; i++) {
            var _a = queue.pop(), node = _a.node, path = _a.path, index = _a.index;
            var context = {};
            if (onNode(node, context, path, index))
                return;
            if (context.cut)
                continue;
            var subnodes = children(node);
            var len_1 = subnodes === null || subnodes === void 0 ? void 0 : subnodes.length;
            if (len_1) {
                for (var i_1 = 0; i_1 < len_1; i_1++) {
                    var subnode = subnodes[i_1];
                    queue.push(new BfsNode(subnode, __spreadArray(__spreadArray([], __read(path), false), [node], false), i_1));
                }
            }
        }
        depth++;
    }
}
/**
 * Map a tree into a new type of tree. Becareful that the node returned by
 * `mapper` should always be a new instance.
 *
 * @example
 * ```ts
 * function map(root: Node, mapper: (node: Node, index: number) => Node) {
 *   return mapTree(
 *     root,
 *     (node) => node.children,
 *     (parent, index, node) => {
 *       parent.children[index] = node
 *     },
 *     mapper,
 *   )
 * }
 *
 * const newTree = map(tree, (node, index) => {
 *   return { ...node, val: node.val * 2 }
 * })
 * ```
 *
 * @param root The tree like object to traverse to.
 * @param children The accessor function that returns the child nodes if any.
 * @param setChild The setter function that writes to a node.
 * @param mapper Function that does the mapping work, it maps the given node
 * to a new node.
 *
 * @returns The whole mapped tree.
 */
function mapTree(root, children, setChild, mapper) {
    return dfs(root, children, null, {
        onLeaf: function (node, context, index) {
            context.returnValue = mapper(node, index);
        },
        onPost: function (node, context, index) {
            var mapped = mapper(node, index);
            for (var i = 0; i < context.childReturns.length; i++) {
                var subnode = context.childReturns[i];
                setChild(mapped, i, subnode);
            }
            context.returnValue = mapped;
        },
    });
}
/**
 * Filter a tree into a new filtered tree.
 *
 * @example
 * ```ts
 * function filter(root: Node, predicate: (node: Node, index: number) => boolean) {
 *   return filterTree(
 *     root,
 *     (node) => node.children,
 *     (parent, index, node) => {
 *       parent.children[index] = node
 *     },
 *     predicate,
 *   )
 * }
 *
 * const newTree = filter(tree, (node, index) => {
 *   return node.val % 2 === 0
 * })
 * ```
 *
 * @param root The tree like object to traverse to.
 * @param children The accessor function that returns the child nodes if any.
 * @param setChild The setter function that writes to a node.
 * @param predicate Function that if it returns `true`, the node will be
 * perserved, and if it returns `false`, the node will be cut from the tree.
 *
 * @returns A filtered new tree.
 */
function filterTree(root, children, setChild, predicate) {
    return rec2iter(function (_a, context) {
        var _b;
        var _c = __read(_a, 2), node = _c[0], index = _c[1];
        if (!((_b = children(node)) === null || _b === void 0 ? void 0 : _b.length)) {
            if (predicate(node, index)) {
                return __assign({}, node);
            }
            else {
                return undefined;
            }
        }
        if (predicate(node, index)) {
            context.recursions = children(node).map(function (n, i) { return [n, i]; });
        }
    }, function (_a, subnodes) {
        var _b = __read(_a, 1), node = _b[0];
        if (subnodes) {
            var copy = __assign({}, node);
            for (var i = 0; i < subnodes.length; i++) {
                var subnode = subnodes[i];
                setChild(copy, i, subnode);
            }
            return copy;
        }
        else {
            return undefined;
        }
    }, [root, 0]);
}

exports.DLinkedList = DLinkedList;
exports.Deque = Deque;
exports.LinkedList = LinkedList;
exports.MaxHeap = MaxHeap;
exports.MaxPriorityQueue = MaxPriorityQueue;
exports.MinHeap = MinHeap;
exports.MinPriorityQueue = MinPriorityQueue;
exports.Queue = Queue;
exports.Stack = Stack;
exports.TraversalContext = TraversalContext;
exports.bfs = bfs;
exports.dfs = dfs;
exports.diff = diff;
exports.every = every;
exports.filter = filter;
exports.filterTree = filterTree;
exports.find = find;
exports.forEach = forEach;
exports.intersection = intersection;
exports.isDst = isDst;
exports.map = map;
exports.mapTree = mapTree;
exports.max = max;
exports.min = min;
exports.mod = mod;
exports.randomInt = randomInt;
exports.rec2iter = rec2iter;
exports.recurse = recurse;
exports.reduce = reduce;
exports.reverseArray = reverseArray;
exports.some = some;
exports.union = union;
exports.waitMs = waitMs;
